\section{Lessons Learned}
\label{sec:lessons_learned}
% Describe the biggest issues, how you solved them, and which are major lessons learned with regards to:
The following section will focus on the lessons learned, significant issues encountered, how they were solved, and reflections on the project.
\subsection{Refactoring}
% - evolution and refactoring
An issue we had when refactoring from the original mini-twit to \cs and ReactJS was \textit{transcribing} the flask frontend to ReactJS. The team had not much experience with the framework before working on the project, though the biggest issue was understanding the flask module. The team solved the issue by researching a bit before ignoring the flask frontend and make the UI with inspiration from how the original UI looked. The team got a better grasp of python when refactoring to \cs.
C\# was chosen for the backend for convenience, since most of the team had experience with it, and did not wish to learn a new language on top of the rest of the course material.
Since the initial refactor, we have incrementally refactored the backend, first migrating from accessing the database through raw SQL to using an object relational mapper. After doing the initial refactor to raw SQL, it became apparent that not immediately adding an the abstraction layer of an object relational mapper meant wasted effort, since we had to completely rewrite the initial refactor for this purpose during the following weeks.
We have decoupled the original MiniTwit class into separate classes, this adhering to the single responsibility principle. Continually adding tests while refactoring allowed us to regression test changes and these served as the basis for the\hyperref[subsubsec:ci]{CI chain}.


\subsection{Operation}
We now see the benefits of infrastructure as code. The original legacy system felt fickle as it had undocumented manual changes, thus reverting or redeploying becomes extremely hard. And without logging all changes to the system, it becomes impossible to reach a state of transparency where every team member knows what is going on in the system. After implementing infrastructure as code for provisioning a cluster\footnote{Create a K8s-Cluster provisioning script \#5\cite{opsIssue5}} we had exact documentation of was done to the system and reprovision was automated. Infrastructure as code is a practice we will use in the future.
\subsection{Maintenance}
% - operation, and maintenance of your ITU-MiniTwit systems. Link back to respective commit messages, issues, tickets, etc. to illustrate these.
As the simulation were running, we made maintenance on the program, fixing issues such as authentication for the simulator as it did not seem to be working on the start day of the simulation, which we caught onto and fixed in the same evening\footnote{pull request fixing login \& register\cite{loginIssue}}.
We figured out the issue might was something with checks in the backend, and forgetting to await async calls from the controllers. While fixing this issue we did some clean up on the affected parts of the code to have cleaner code and prevent that some odd code would case unexpected bugs. However, this issue caused us to lose data as we could not register users, but after the refactoring the code, when the next batch of users from the simulation were sent to our API the problem no longer occurred.
Another issue we had were that our follow and unfollow endpoints suddenly stopped working\footnote{issue illustrating problem\cite{issue172}}. The problem were indirectly solved when we did more refactoring on the system, however we would likely not have caught the issue if it were not for the monitoring we had implemented at that time.\\
Our follower issue were related to inconsistent or missing user data in the database, which was a common issue among the other groups, which has definitely made us realize the importance of keeping a backup of the database at all times, in case of data loss either from a bug or from making changes to the database implementation. This is especially important when serving live users, which the simulation allowed us to do, as service up time and data consistency is essential for users of a system.

\subsection{DevOps Adaptation}
% - Also reflect and describe what was the "DevOps" style of your work. For example, what did you do differently to previous development projects and how did it work?
The most notable difference from earlier projects was incrementally releasing in small batches by adopting the flow principle. Continually providing value instead of doing 1 big hand-off made it a lot easier to focus on finishing individual assignment. It did however limit options for distributing work a little. For example, it is hard for multiple people to be productive when setting up a droplet on DigitalOcean or creating a CD workflow file. 
Releasing in small batches was made possible by ensuring quality and deploying automatically with each increment using the CI/CD chain described in \ref{subsec:cicd}. It also provided us with instantaneous feedback through the CI chain, allowing us to quickly solve problems and keep a consistent level of code quality. We realize now, that at least minimal CI should be present in all projects, and we will implement it in future projects.
Continual Learning and Experimentation are something we have not done in previous projects, but also something we feel lacked in our adaptation of DevOps. While we did learn a wide range of new tools. We feel, we stagnated in improving our development practices between increments. This might have been solved by implementing something akin to a retrospective meeting focusing on what to improve.\\
The course has ultimately given us a wide range tools and technologies for developing, maintaining, and operating software. Some of which definitely will prove useful for future projects and when we enter industry.